# 숫자 짝꿍
## 문제 설명

두 정수 X, Y의 임의의 자리에서 공통으로 나타나는 정수 k(0 ≤ k ≤ 9)들을 이용하여 만들 수 있는 가장 큰 정수를 두 수의 짝꿍이라 합니다(단, 공통으로 나타나는 정수 중 서로 짝지을 수 있는 숫자만 사용합니다). X, Y의 짝꿍이 존재하지 않으면, 짝꿍은 -1입니다. X, Y의 짝꿍이 0으로만 구성되어 있다면, 짝꿍은 0입니다.
예를 들어, X = 3403이고 Y = 13203이라면, X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 3, 0, 3으로 만들 수 있는 가장 큰 정수인 330입니다. 다른 예시로 X = 5525이고 Y = 1255이면 X와 Y의 짝꿍은 X와 Y에서 공통으로 나타나는 2, 5, 5로 만들 수 있는 가장 큰 정수인 552입니다(X에는 5가 3개, Y에는 5가 2개 나타나므로 남는 5 한 개는 짝 지을 수 없습니다.)
두 정수 X, Y가 주어졌을 때, X, Y의 짝꿍을 return하는 solution 함수를 완성해주세요.
## 제한사항
3 ≤ X, Y의 길이(자릿수) ≤ 3,000,000입니다.
X, Y는 0으로 시작하지 않습니다.
X, Y의 짝꿍은 상당히 큰 정수일 수 있으므로, 문자열로 반환합니다.
## 입출력 예
X	Y	result
"100"	"2345"	"-1"
"100"	"203045"	"0"
"100"	"123450"	"10"
"12321"	"42531"	"321"
"5525"	"1255"	"552"
## 입출력 예 설명
### 입출력 예 #1
X, Y의 짝꿍은 존재하지 않습니다. 따라서 "-1"을 return합니다.
### 입출력 예 #2
X, Y의 공통된 숫자는 0으로만 구성되어 있기 때문에, 두 수의 짝꿍은 정수 0입니다. 따라서 "0"을 return합니다.
### 입출력 예 #3
X, Y의 짝꿍은 10이므로, "10"을 return합니다.
### 입출력 예 #4
X, Y의 짝꿍은 321입니다. 따라서 "321"을 return합니다.
### 입출력 예 #5
지문에 설명된 예시와 같습니다.

***

매우 큰 정수를 문자열로 받아, 두 문자열에 공통으로 존재하는 정수를 큰 수의 순서대로 반환하면 되는 문제같다.

주의해야할 점은 두 문자열의 짝이 0으로만 이루어져 있다면, 0을 반환해야한다.
find()함수를 사용해서 X를 돌면서 Y를 지워주었는데, 시간초과가 난다. 거기다가 answer가 0으로만 이루어진 경우를 처리하기 위해 stoull를 써봤지만 core dumped가 나는 걸 보니 숫자가 너무 커서 그런건가 싶다. find()함수를 쓰면 궁극적으로 O(n^2)의 시간복잡도가 되는 것 같아 아무래도 알고리즘을 수정해야겠다.

그럼 시간 복잡도를 줄이려면, 두 문자열 동시에 하나씩 돌면서 문제를 풀어야겠다. map 형식의 각 숫자 수를 저장할 변수를 선언해주어서 두 문자열을 하나씩 돌면서 X는 하나씩 더해주고 Y는 하나씩 빼주는 식으로 카운트를 진행해주었다. 시간초과는 해결했으나 core dumped 문제가 생겼다. 이는 정해진 range를 벗어났거나 변수의 범위를 넘어서는 과정일 때 일어나는 에러인데 왜 그런 문제가 생긴 것일까.

결국 과정을 다 진행해준 뒤에 sort까지 끝내고 난 뒤에도 맨 앞 수가 0이면 전부 0이란 말이 되어 예외처리르 바꾸어주었더니 문제가 풀렸다.
다른 풀이를 보니 그냥 모든 string을 돌면서 개수를 세어주고 마지막에 두 개수를 비교하면서 작은 수를 처리하면 문제가 쉽게 풀리는 것을 보았다. 생각이 여전히 짧았던 것 같다.

***
문제 링크: [링크](https://school.programmers.co.kr/learn/courses/30/lessons/131128)