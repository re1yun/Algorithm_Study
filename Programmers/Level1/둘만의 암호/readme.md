# 둘만의 암호
## 문제 설명

두 문자열 s와 skip, 그리고 자연수 index가 주어질 때, 다음 규칙에 따라 문자열을 만들려 합니다. 암호의 규칙은 다음과 같습니다.
문자열 s의 각 알파벳을 index만큼 뒤의 알파벳으로 바꿔줍니다.
index만큼의 뒤의 알파벳이 z를 넘어갈 경우 다시 a로 돌아갑니다.
skip에 있는 알파벳은 제외하고 건너뜁니다.
예를 들어 s = "aukks", skip = "wbqd", index = 5일 때, a에서 5만큼 뒤에 있는 알파벳은 f지만 [b, c, d, e, f]에서 'b'와 'd'는 skip에 포함되므로 세지 않습니다. 따라서 'b', 'd'를 제외하고 'a'에서 5만큼 뒤에 있는 알파벳은 [c, e, f, g, h] 순서에 의해 'h'가 됩니다. 나머지 "ukks" 또한 위 규칙대로 바꾸면 "appy"가 되며 결과는 "happy"가 됩니다.
두 문자열 s와 skip, 그리고 자연수 index가 매개변수로 주어질 때 위 규칙대로 s를 변환한 결과를 return하도록 solution 함수를 완성해주세요.
## 제한사항
5 ≤ s의 길이 ≤ 50
1 ≤ skip의 길이 ≤ 10
s와 skip은 알파벳 소문자로만 이루어져 있습니다.
skip에 포함되는 알파벳은 s에 포함되지 않습니다.
1 ≤ index ≤ 20
## 입출력 예
s	skip	index	result
"aukks"	"wbqd"	5	"happy"
## 입출력 예 설명
### 입출력 예 #1
본문 내용과 일치합니다.

***

주어진 s의 각 알파벳을 index만큼 뒤에 있는 알파벳으로 바꿔주기만 하면 되는 문제이지만, 문제는 skip에 포함된 알파벳은 index 카운트에서 제외해야한다.
각 문자열의 알파벳을 ascii로 바꾸어 만약 skip에 해당되는 숫자보다 크다면 index에 추가로 더해 새로운 알파벳을 찾으면 될 것 같다.
// what is ascii code of alphabet 'a' and 'z'? 97, 122

문제 풀다가 생각을 바꿨다. 그냥 알파벳을 하나씩 올려주면서 skip string에서 find()되면 넘어가고 아니면 인덱스 수만큼 넘어가는 식으로 바꿨다.
처음 생각이 왜 말이 안되냐면, 인덱스만큼 늘려준 다음에 그보다 작은 알파벳을 skip에서 찾으면 늘어진만큼 사이에 존재하는 또 다른 skip에 해당되는 알파벳이 계속 나올 수 있기 때문이다. 그래서 그냥 하나씩 늘려주면서 skip에서 찾아주었다.


***
문제 링크 : [링크](https://school.programmers.co.kr/learn/courses/30/lessons/155652)