# 2개 이하로 다른 비트
## 문제 설명

양의 정수 x에 대한 함수 f(x)를 다음과 같이 정의합니다.
x보다 크고 x와 비트가 1~2개 다른 수들 중에서 제일 작은 수
예를 들어,
f(2) = 3 입니다. 다음 표와 같이 2보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 3이기 때문입니다.
수	비트	다른 비트의 개수
2	000...0010	
3	000...0011	1
f(7) = 11 입니다. 다음 표와 같이 7보다 큰 수들 중에서 비트가 다른 지점이 2개 이하이면서 제일 작은 수가 11이기 때문입니다.
수	비트	다른 비트의 개수
7	000...0111	
8	000...1000	4
9	000...1001	3
10	000...1010	3
11	000...1011	2
정수들이 담긴 배열 numbers가 매개변수로 주어집니다. numbers의 모든 수들에 대하여 각 수의 f 값을 배열에 차례대로 담아 return 하도록 solution 함수를 완성해주세요.
## 제한사항
1 ≤ numbers의 길이 ≤ 100,000
0 ≤ numbers의 모든 수 ≤ 1015
## 입출력 예
numbers	result
[2,7]	[3,11]
## 입출력 예 설명
### 입출력 예 #1
문제 예시와 같습니다.

***

비트 연산이 떠오르는 문제이다. 비트 관련 문제는 항상 어렵다.
일단 2비트로 변환이 필요하고, 해당 비트에서 숫자가 올라가는 만큼 새로운 비트가 필요하다. 거기에 더해서 변환된 비트를 가지고 자리수가 다른지 확인해야하기 때문에 또 다른 연산이 추가된다.

이번 문제의 경우, bitwise operation xor ^ 를 사용하면 좋을 것 같다. xor의 경우, 두 수가 같으면 false, 다르면 true를 반환한다. 따라서 xor 연산 뒤에 나온 수를 가지고, 2진수로 전환했을 때 1이 두개 이하가 나오면 답이라 정의할 수 있다. 
이러한 연산은 1과 and & 연산을 진행했을 때, 1의 자리 숫자가 1인지 아닌지 확인할 수 있다. 그리고 찾으려는 숫자를 n >>= 1 right shift연산을 통해 자리수를 줄여주며 위를 반복하면 1 비트 수를 계산할 수 있다.

int countSetBit(long long n){
    int count = 0;
    while(n){
        count += (n & 1);
        if(count >= 3)
            return count;
        n >>= 1;
    }
    return count;
}

vector<long long> solution(vector<long long> numbers) {
    // init
    vector<long long> answer;
    
    // algorithm
    for(long long num : numbers){
        long long nextNum = num + 1;
        while(true){
            if(countSetBit(num ^ nextNum) <= 2){
                answer.push_back(nextNum);
                break;
            }
            nextNum++;
        }
    }
    return answer;
}

이렇게 구현을 했는데 계속 시간초과가 발생했다. 이유는 아무래도 주어지는 수가 매우 크다보니, 각각의 수를 전부 비트로 1의 개수를 찾다보면, 특히나 나누기 연산이 포함되어있어 연산 시간에 취약하다. 따라서 다른 방법은 짝수의 경우 1을 더한 것이 비트의 개수가 1~2개 다르면서 가장 작은 수가 되겠고, 홀수의 경우, 2진수에서 1의 자리가 연속적으로 붙어있는만큼 더해주면 비트의 수가 1~2개 다르며 가장 작은 수가 되겠다.

***
문제 링크: [링크](https://school.programmers.co.kr/learn/courses/30/lessons/77885)
