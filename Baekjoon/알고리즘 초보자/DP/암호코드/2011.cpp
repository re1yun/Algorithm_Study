/*
일단 알파벳은 1부터 26까지 있다. 
5000자리의 수를 가지고 가능한 모든 경우의 수를 찾는 것이 목표임.
25114는 2 5 1 14 / 25 1 1 4 / 25 11 4 / 25 1 14 / 2 5 11 4 / 2 5 1 1 4 총 6가지가 존재함
첫번째, 한자리 수만 가지고 만들 수 있는 경우의 수가 존재함 -> 2 5 1 1 4
두번째, 두자리 수로 만들 수 있는 경우의 수가 존재함 -> 25 11 4
셋번째, 두 개를 섞은 경우의 수가 존재함 -> 2 5 1 14 / 2 5 11 4 / 25 1 1 4 / 25 1 14
네번째, 만약 0이 있다면, 이 수는 무조건 앞에 있는 수와 붙어있어야함.
1이나 2가 나오면 2개의 경우의 수가 생김. 2를 곱해주어야하나?
2 5 1 1 4 -> 2 * 2
11 -> 2 * 1
121 -> 2 * 1 + 1// 1 2 1 / 1 21 / 12 1 
1221 -> 1 + 1 + 2 * 2 -> 6? // 1 2 2 1 / 12 21 / 1 2 21 / 1 22 1 / 12 2 1

*/
#include <iostream>
#include <string>

using namespace std;

int main(){
    string code;            cin >> code;
    int A[5001] = {0,};
    for(int i = 1; i <= code.length(); i++){
        A[i] = code[i - 1] - '0';
    }
    if(code[0] == '0'){
        cout << 0;
        return 0;
    }
    int dp[5001] = {0,};
    dp[0] = 1;
    for(int i = 1; i <= code.length(); i++){
        if(A[i] >= 1 && A[i] <= 9){
            dp[i] = (dp[i - 1] + dp[i]) % 1000000;
        }
        if(i == 1)
            continue;
        int Temp = A[i] + A[i - 1] * 10;
        if (Temp >= 10 && Temp <= 26)
        {
            dp[i] = (dp[i - 2] + dp[i]) % 1000000;
        }
    }
    cout << dp[code.length()];
    return 0;
}